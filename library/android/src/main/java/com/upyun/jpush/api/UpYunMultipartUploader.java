/** * com.upyun.api * Upload.java */package com.upyun.jpush.api;import com.loopj.android.jpush.http.SyncHttpClient;import com.upyun.jpush.api.common.Params;import com.upyun.jpush.api.listener.CompleteListener;import com.upyun.jpush.api.listener.ProgressListener;import com.upyun.jpush.api.main.CountingHttpEntity;import com.upyun.jpush.api.utils.UpYunUtils;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.StatusLine;import org.apache.http.client.HttpClient;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import org.apache.jpush.http.entity.mime.HttpMultipartMode;import org.apache.jpush.http.entity.mime.MultipartEntity;import org.apache.jpush.http.entity.mime.content.ByteArrayBody;import org.apache.jpush.http.entity.mime.content.StringBody;import org.json.JSONArray;import org.json.JSONObject;import java.io.File;import java.io.FileNotFoundException;import java.io.RandomAccessFile;import java.util.ArrayList;import java.util.Calendar;import java.util.HashMap;import java.util.List;import java.util.TreeSet;import cn.jpush.im.android.utils.StringUtils;/** * 分块上传SDK * * @author wangxiaolong */public class UpYunMultipartUploader {    public final static String APPLICATION_OCTET_STREAM = "application/octet-stream";    public static final int MIN_BLOCK_SIZE = 100 * 1024;// 100K    public static final int BLOCK_SIZE = 512 * 1024;    // private final String boundary =    // "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";    private String host = "http://m0.api.upyun.com/";    private String bucket;    private long expiration = Calendar.getInstance().getTimeInMillis() + 60 * 1000; // 60s    private String saveToken;    private String tokenSecret;    private File localFile;    private ProgressListener progressListener = null;    private CompleteListener completeListener = null;    private int totalBlockNum;    private static SyncHttpClient client = new SyncHttpClient();    public UpYunMultipartUploader(String bucket) {        this.bucket = bucket;        client.setConnectTimeout(UpyunUploadManager.CONNECT_TIMEOUT);        client.setResponseTimeout(UpyunUploadManager.RESPONSE_TIMEOUT);        client.setEnableRedirects(false);    }    // get & set    private String getBucket() {        return this.bucket;    }    public String getHost() {        return host;    }    public void setHost(String host) {        this.host = host;    }    public int getBlockSize() {        return BLOCK_SIZE;    }    public long getExpiration() {        return expiration;    }    public void setExpiration(long expiration) {        this.expiration = expiration;    }    /**     * 获取文件元信息 计算policy、signature需要此信息     *     * @param localFile     * @param savePath     * @return     * @throws UpYunException     * @throws FileNotFoundException     */    // public Map<String, Object> fetchFileInfoDictionaryWith(File localFile,    // String savePath) throws UpYunException, FileNotFoundException {    // HashMap<String, Object> paramsMap = new HashMap<String, Object>();    // paramsMap.put(Params.PATH, savePath);    // paramsMap.put(Params.EXPIRATION, expiration);    // paramsMap.put(Params.BLOCK_NUM,    // UpYunUtils.getBlockNum(localFile, blockSize));    // paramsMap.put(Params.FILE_SIZE, localFile.length());    // paramsMap.put(    // Params.FILE_MD5,    // StringUtil.toMD5(    // FileUtil.File2byte(localFile.getAbsolutePath()))    // .toLowerCase());    //    // return paramsMap;    // }    /**     * 获取请求url     */    private String getUrl(String bucket) {        return this.host + bucket + "/";    }    public void upload(String policy, String signature, File localFile,            ProgressListener progressListener, CompleteListener completeListener) throws Exception {        this.localFile = localFile;        this.progressListener = progressListener;        this.completeListener = completeListener;        this.totalBlockNum = UpYunUtils.getBlockNum(localFile, BLOCK_SIZE);        // 初始化上传        JSONObject initialResult = initialUpload(policy, signature);        if (initialResult.has(Params.ERROR_CODE)) {                /*                 * 出错时返回：				 * {"X-Request-Id":"11d88831c76213d9082457e55b8ff478","message"				 * :"Bucket NotFound.","error_code":40401,"code":404}				 * "X-Request-Id"说明：出现错误时，将该字段值提供给又拍云，可以用来排查错误				 */            int code = initialResult.getInt(Params.CODE);            completeListener.result(false, code, initialResult.toString());            return;        }        saveToken = initialResult.optString(Params.SAVE_TOKEN);        tokenSecret = initialResult.optString(Params.TOKEN_SECRET);        JSONArray array = initialResult.getJSONArray(Params.STATUS);        // 获取未上传的块下标        TreeSet<Integer> blockIndex = new TreeSet<Integer>();        for (int i = 0; i < array.length(); i++) {            if (array.getInt(i) == 0) {                blockIndex.add(i);            }        }        if (blockIndex.size() != 0) {            // 上传分块            uploadBlocks(blockIndex);        }        // 合并分块请求        HashMap<String, Object> paramsMapFinish = new HashMap<String, Object>();        paramsMapFinish.put(Params.EXPIRATION, expiration);        paramsMapFinish.put(Params.SAVE_TOKEN, saveToken);        String policyForMerge = UpYunUtils.getPolicy(paramsMapFinish);        String signatureForMerge = UpYunUtils.getSignature(paramsMapFinish, tokenSecret);        uploadFinish(policyForMerge, signatureForMerge);        return;    }    /**     * 初始化上传     *     * @param policy 文件操作列表（save_token,expiration必须，其他可选参数参见http://docs.upyun.com/     *               api/form_api/#Policy内容详解）     */    private JSONObject initialUpload(String policy, String signature) throws Exception {        // build entity & send request        List<NameValuePair> pairList = new ArrayList<NameValuePair>();        NameValuePair param1 = new BasicNameValuePair(Params.POLICY, policy);        NameValuePair param2 = new BasicNameValuePair(Params.SIGNATURE, signature);        pairList.add(param1);        pairList.add(param2);        HttpEntity entity = new UrlEncodedFormEntity(pairList);        return doPostRequest(entity, getUrl(bucket));    }    /**     * 上传分块     *     * @param blockUnsendIndex 列表中记录未上传的index     */    private void uploadBlocks(TreeSet<Integer> blockUnsendIndex) throws Exception {        JSONObject result = null;        RandomAccessFile randomAccessFile = null;        try {            byte blockTmp[] = new byte[BLOCK_SIZE];            randomAccessFile = new RandomAccessFile(localFile, "r");            HashMap<String, Object> policyMap = new HashMap<String, Object>();            policyMap.put(Params.SAVE_TOKEN, saveToken);            policyMap.put(Params.EXPIRATION, expiration);            int readedBlocks = 0;            int readedSize = 0;            int sendedBlockCount = totalBlockNum - blockUnsendIndex.size();            for (Integer index : blockUnsendIndex) {                for (int i = 0; i < (index - readedBlocks); i++) {                    randomAccessFile.read(blockTmp, 0, BLOCK_SIZE);                }                readedSize = randomAccessFile.read(blockTmp, 0, BLOCK_SIZE);                if (readedSize == -1) {                    throw new IndexOutOfBoundsException("文件读取越界");                }                readedBlocks = index + 1;                policyMap.put(Params.BLOCK_INDEX, index);                JSONObject resultTmp = null;                if (index == (totalBlockNum - 1)) { // 最后一个block不一定是满的，特殊处理一下                    byte[] lastBlock = new byte[readedSize];                    System.arraycopy(blockTmp, 0, lastBlock, 0, readedSize);                    policyMap.put(Params.BLOCK_MD5, StringUtils.toMD5(lastBlock).toLowerCase());                    resultTmp = uploadBlockProxy(policyMap, lastBlock,                            sendedBlockCount * BLOCK_SIZE, localFile.length());                } else {                    policyMap.put(Params.BLOCK_MD5, StringUtils.toMD5(blockTmp).toLowerCase());                    resultTmp = uploadBlockProxy(policyMap, blockTmp, sendedBlockCount * BLOCK_SIZE,                            localFile.length());                }                int code = resultTmp.getInt(Params.CODE);                if (code < 400) {                    sendedBlockCount++;                    result = resultTmp;                } else {                    completeListener.result(false, code, resultTmp.toString());                    return;                }            }        } finally {            if (randomAccessFile != null) {                randomAccessFile.close();            }        }        return;    }    private JSONObject uploadBlockProxy(HashMap<String, Object> map, byte[] block, long bytesSended,            long totalBytes) throws Exception {        String policy = UpYunUtils.getPolicy(map);        String signature = UpYunUtils.getSignature(map, this.tokenSecret);        MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);        entity.addPart("file", new ByteArrayBody(block, APPLICATION_OCTET_STREAM, "block"));        entity.addPart("policy", new StringBody(policy));        entity.addPart("signature", new StringBody(signature));        if (progressListener != null) {            CountingHttpEntity ce = new CountingHttpEntity(entity, progressListener, bytesSended,                    totalBytes);            return doPostRequest(ce, getUrl(bucket));        }        return doPostRequest(entity, getUrl(bucket));    }    /**     * 合并分块请求（分块全部上传成功后请求服务端合并分块）     *     * @param policy 文件操作列表（save_token,expiration必须，其他可选参数参见http://docs.upyun.com/     *               api/form_api/#Policy内容详解）     */    private void uploadFinish(String policy, String signature) throws Exception {        // build entity & send request        List<NameValuePair> paramList = new ArrayList<NameValuePair>();        NameValuePair param1 = new BasicNameValuePair(Params.POLICY, policy);        NameValuePair param2 = new BasicNameValuePair(Params.SIGNATURE, signature);        paramList.add(param1);        paramList.add(param2);        HttpEntity entity = new UrlEncodedFormEntity(paramList);        JSONObject result = doPostRequest(entity, getUrl(bucket));        int code = result.getInt(Params.CODE);        if (code == 302) {            JSONObject callbackResult = doGetRequest(result.getString(Params.LOCATION));            int callbackCode = callbackResult.getInt(Params.CODE);            if (callbackCode == 200) {                completeListener.result(true, callbackCode, callbackResult.toString());            } else {                completeListener.result(false, callbackCode, callbackResult.toString());            }        } else if (result.has(Params.ERROR_CODE)) {            completeListener.result(false, code, result.toString());        } else {            completeListener.result(true, code, result.toString());        }    }    /**     * 发送请求     */    private JSONObject doPostRequest(HttpEntity entity, String url) throws Exception {        JSONObject result = new JSONObject();        // RequestHandle handle = client.post(context, url, entity,        // contentType, responseHandler);        HttpClient httpclient = client.getHttpClient();        HttpPost httpPost = new HttpPost(url);        httpPost.setEntity(entity);        HttpResponse response = httpclient.execute(httpPost);        StatusLine statusLine = response.getStatusLine();        int code = statusLine.getStatusCode();        if (code == 302) {            result.put(Params.CODE, code);            result.put(Params.LOCATION, response.getHeaders(Params.LOCATION)[0].getValue());        } else {            String responseJson = EntityUtils.toString(response.getEntity());            JSONObject jsonObj = new JSONObject(responseJson);            if (code == 200 || code == 201) {                result = jsonObj;                result.put(Params.CODE, code);            } else {                if (jsonObj.has(Params.ERROR_CODE)) {                    result.put(Params.ERROR_CODE, jsonObj.getInt(Params.ERROR_CODE));                }                result.put(Params.CODE, code);                result.put(Params.X_Request_Id,                        response.getHeaders(Params.X_Request_Id)[0].getValue());                result.put(Params.MESSAGE, jsonObj.getString(Params.MESSAGE));            }        }        return result;    }    private JSONObject doGetRequest(String url) throws Exception {        JSONObject result = null;        HttpClient httpclient = client.getHttpClient();        HttpGet httpGet = new HttpGet(url);        HttpResponse response = httpclient.execute(httpGet);        StatusLine statusLine = response.getStatusLine();        int code = statusLine.getStatusCode();        String responseJson = EntityUtils.toString(response.getEntity());        result = new JSONObject(responseJson);        result.put(Params.CODE, code);        result.put(Params.LOCATION, url);        return result;    }}